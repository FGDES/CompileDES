/* rti2code: autogenerated libFAUDES rti registration: libFAUDES 2.29d timed-iodevice-simulator */

namespace faudes {
void LoadRegisteredTypes(void);
} // namespace
namespace faudes {
void LoadRegisteredFunctions(void);
} // namespace
namespace faudes {
/* Function class for C++ function Accessible*/
class Rti0Accessible : public Function { 
public:
Rti0Accessible(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti0Accessible(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_1_0;
Generator* mP_1_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant G:=Acc(G)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant GRes:=Acc(GArg)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_1_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant G:=Acc(G)
    Accessible(*mP_0_0); break; };
  case 1: { // variant GRes:=Acc(GArg)
    Accessible(*mP_1_0 ,*mP_1_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function SetDifference*/
class Rti1SetDifference : public Function { 
public:
Rti1SetDifference(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti1SetDifference(pFuncDef); };
protected:
EventSet* mP_0_0;
EventSet* mP_0_1;
EventSet* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Sigma=Sigma1 - Sigma2
    switch(n) { 
    case 0:     res=DoTypeCast<EventSet>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<EventSet>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Sigma=Sigma1 - Sigma2
    SetDifference(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function SetEquality*/
class Rti2SetEquality : public Function { 
public:
Rti2SetEquality(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti2SetEquality(pFuncDef); };
protected:
EventSet* mP_0_0;
EventSet* mP_0_1;
Boolean* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Sigma1 == Sigma2
    switch(n) { 
    case 0:     res=DoTypeCast<EventSet>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Boolean>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Sigma1 == Sigma2
    *(mP_0_2->CReference()) = SetEquality(*mP_0_0 ,*mP_0_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function AlphabetExtract*/
class Rti3AlphabetExtract : public Function { 
public:
Rti3AlphabetExtract(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti3AlphabetExtract(pFuncDef); };
protected:
Generator* mP_0_0;
EventSet* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Sigma(Gen)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Sigma(Gen)
    AlphabetExtract(*mP_0_0 ,*mP_0_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function SetInclusion*/
class Rti4SetInclusion : public Function { 
public:
Rti4SetInclusion(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti4SetInclusion(pFuncDef); };
protected:
EventSet* mP_0_0;
EventSet* mP_0_1;
Boolean* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Sigma1 <= Sigma2
    switch(n) { 
    case 0:     res=DoTypeCast<EventSet>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Boolean>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Sigma1 <= Sigma2
    *(mP_0_2->CReference()) = SetInclusion(*mP_0_0 ,*mP_0_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function SetIntersection*/
class Rti5SetIntersection : public Function { 
public:
Rti5SetIntersection(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti5SetIntersection(pFuncDef); };
protected:
EventSet* mP_0_0;
EventSet* mP_0_1;
EventSet* mP_0_2;
EventSetVector* mP_1_0;
EventSet* mP_1_1;
GeneratorVector* mP_2_0;
EventSet* mP_2_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Sigma=Sigma1 ^ Sigma2
    switch(n) { 
    case 0:     res=DoTypeCast<EventSet>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<EventSet>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant Sigma = ^_i(Sigma_i)
    switch(n) { 
    case 0:     res=DoTypeCast<EventSetVector>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_1_1); break; 
    default: break; 
    } 
    break; 
  } 
  case 2: { // variant Sigma = ^_i(Sigma(Gen_i))
    switch(n) { 
    case 0:     res=DoTypeCast<GeneratorVector>(0, mP_2_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_2_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Sigma=Sigma1 ^ Sigma2
    SetIntersection(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  case 1: { // variant Sigma = ^_i(Sigma_i)
    SetIntersection(*mP_1_0 ,*mP_1_1); break; };
  case 2: { // variant Sigma = ^_i(Sigma(Gen_i))
    SetIntersection(*mP_2_0 ,*mP_2_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function AlphabetLanguage*/
class Rti6AlphabetLanguage : public Function { 
public:
Rti6AlphabetLanguage(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti6AlphabetLanguage(pFuncDef); };
protected:
EventSet* mP_0_0;
Generator* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Lm(GRes) = Sigma
    switch(n) { 
    case 0:     res=DoTypeCast<EventSet>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Lm(GRes) = Sigma
    AlphabetLanguage(*mP_0_0 ,*mP_0_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function SetUnion*/
class Rti7SetUnion : public Function { 
public:
Rti7SetUnion(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti7SetUnion(pFuncDef); };
protected:
EventSet* mP_0_0;
EventSet* mP_0_1;
EventSet* mP_0_2;
EventSetVector* mP_1_0;
EventSet* mP_1_1;
GeneratorVector* mP_2_0;
EventSet* mP_2_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Sigma=Sigma1 v Sigma2
    switch(n) { 
    case 0:     res=DoTypeCast<EventSet>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<EventSet>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant Sigma = v_i(Sigma_i)
    switch(n) { 
    case 0:     res=DoTypeCast<EventSetVector>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_1_1); break; 
    default: break; 
    } 
    break; 
  } 
  case 2: { // variant Sigma = v_i(Sigma(Gen_i))
    switch(n) { 
    case 0:     res=DoTypeCast<GeneratorVector>(0, mP_2_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_2_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Sigma=Sigma1 v Sigma2
    SetUnion(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  case 1: { // variant Sigma = v_i(Sigma_i)
    SetUnion(*mP_1_0 ,*mP_1_1); break; };
  case 2: { // variant Sigma = v_i(Sigma(Gen_i))
    SetUnion(*mP_2_0 ,*mP_2_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function Automaton*/
class Rti8Automaton : public Function { 
public:
Rti8Automaton(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti8Automaton(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_1_0;
EventSet* mP_1_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Automaton(GArg)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant Automaton(GArg, Sigma)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_1_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Automaton(GArg)
    Automaton(*mP_0_0); break; };
  case 1: { // variant Automaton(GArg, Sigma)
    Automaton(*mP_1_0 ,*mP_1_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function Coaccessible*/
class Rti9Coaccessible : public Function { 
public:
Rti9Coaccessible(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti9Coaccessible(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_1_0;
Generator* mP_1_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant G:=CoAcc(G)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant GRes:=CoAcc(GArg)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_1_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant G:=CoAcc(G)
    Coaccessible(*mP_0_0); break; };
  case 1: { // variant GRes:=CoAcc(GArg)
    Coaccessible(*mP_1_0 ,*mP_1_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function Complete*/
class Rti10Complete : public Function { 
public:
Rti10Complete(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti10Complete(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_1_0;
Generator* mP_1_1;
Generator* mP_2_0;
EventSet* mP_2_1;
Generator* mP_3_0;
EventSet* mP_3_1;
Generator* mP_3_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant G:=Complete(G)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant GRes:=Complete(G)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_1_1); break; 
    default: break; 
    } 
    break; 
  } 
  case 2: { // variant G:=Complete(G,SigmaO)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_2_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_2_1); break; 
    default: break; 
    } 
    break; 
  } 
  case 3: { // variant GRes:=Complete(G,SigmaO)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_3_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_3_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_3_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant G:=Complete(G)
    Complete(*mP_0_0); break; };
  case 1: { // variant GRes:=Complete(G)
    Complete(*mP_1_0 ,*mP_1_1); break; };
  case 2: { // variant G:=Complete(G,SigmaO)
    Complete(*mP_2_0 ,*mP_2_1); break; };
  case 3: { // variant GRes:=Complete(G,SigmaO)
    Complete(*mP_3_0 ,*mP_3_1 ,*mP_3_2); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function aDeterministic*/
class Rti11aDeterministic : public Function { 
public:
Rti11aDeterministic(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti11aDeterministic(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Deterministic(G,GRes)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Deterministic(G,GRes)
    aDeterministic(*mP_0_0 ,*mP_0_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function EmptyLanguage*/
class Rti12EmptyLanguage : public Function { 
public:
Rti12EmptyLanguage(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti12EmptyLanguage(pFuncDef); };
protected:
EventSet* mP_0_0;
Generator* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Lm(GRes) := 0
    switch(n) { 
    case 0:     res=DoTypeCast<EventSet>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Lm(GRes) := 0
    EmptyLanguage(*mP_0_0 ,*mP_0_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function EmptyStringLanguage*/
class Rti13EmptyStringLanguage : public Function { 
public:
Rti13EmptyStringLanguage(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti13EmptyStringLanguage(pFuncDef); };
protected:
EventSet* mP_0_0;
Generator* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Lm(GRes) = {epsilon}
    switch(n) { 
    case 0:     res=DoTypeCast<EventSet>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Lm(GRes) = {epsilon}
    EmptyStringLanguage(*mP_0_0 ,*mP_0_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function FullLanguage*/
class Rti14FullLanguage : public Function { 
public:
Rti14FullLanguage(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti14FullLanguage(pFuncDef); };
protected:
EventSet* mP_0_0;
Generator* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant L(GRes) = Sigma*
    switch(n) { 
    case 0:     res=DoTypeCast<EventSet>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant L(GRes) = Sigma*
    FullLanguage(*mP_0_0 ,*mP_0_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IntegerSum*/
class Rti15IntegerSum : public Function { 
public:
Rti15IntegerSum(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti15IntegerSum(pFuncDef); };
protected:
Integer* mP_0_0;
Integer* mP_0_1;
Integer* mP_0_2;
IntegerVector* mP_1_0;
Integer* mP_1_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant IRes=I_1+I_2
    switch(n) { 
    case 0:     res=DoTypeCast<Integer>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Integer>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Integer>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant IRes=Sum_i I_i
    switch(n) { 
    case 0:     res=DoTypeCast<IntegerVector>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<Integer>(1, mP_1_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant IRes=I_1+I_2
    *(mP_0_2->CReference()) = IntegerSum(*(mP_0_0->CReference()) ,*(mP_0_1->CReference())); break; };
  case 1: { // variant IRes=Sum_i I_i
    *(mP_1_1->CReference()) = IntegerSum(*mP_1_0); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function aInvProject*/
class Rti16aInvProject : public Function { 
public:
Rti16aInvProject(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti16aInvProject(pFuncDef); };
protected:
Generator* mP_0_0;
EventSet* mP_0_1;
Generator* mP_1_0;
EventSet* mP_1_1;
Generator* mP_1_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant InvProject(G0,Sigma)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant InvProject(G0,Sigma,GRes)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_1_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_1_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant InvProject(G0,Sigma)
    aInvProject(*mP_0_0 ,*mP_0_1); break; };
  case 1: { // variant InvProject(G0,Sigma,GRes)
    aInvProject(*mP_1_0 ,*mP_1_1 ,*mP_1_2); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsAccessible*/
class Rti17IsAccessible : public Function { 
public:
Rti17IsAccessible(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti17IsAccessible(pFuncDef); };
protected:
Generator* mP_0_0;
Boolean* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Default
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Boolean>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Default
    *(mP_0_1->CReference()) = IsAccessible(*mP_0_0); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsCoaccessible*/
class Rti18IsCoaccessible : public Function { 
public:
Rti18IsCoaccessible(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti18IsCoaccessible(pFuncDef); };
protected:
Generator* mP_0_0;
Boolean* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Default
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Boolean>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Default
    *(mP_0_1->CReference()) = IsCoaccessible(*mP_0_0); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsComplete*/
class Rti19IsComplete : public Function { 
public:
Rti19IsComplete(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti19IsComplete(pFuncDef); };
protected:
Generator* mP_0_0;
Boolean* mP_0_1;
Generator* mP_1_0;
EventSet* mP_1_1;
Boolean* mP_1_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant IsComplete(G)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Boolean>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant IsComplete(G,SigmaO)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_1_1); break; 
    case 2:     res=DoTypeCast<Boolean>(2, mP_1_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant IsComplete(G)
    *(mP_0_1->CReference()) = IsComplete(*mP_0_0); break; };
  case 1: { // variant IsComplete(G,SigmaO)
    *(mP_1_2->CReference()) = IsComplete(*mP_1_0 ,*mP_1_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsDeterministic*/
class Rti20IsDeterministic : public Function { 
public:
Rti20IsDeterministic(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti20IsDeterministic(pFuncDef); };
protected:
Generator* mP_0_0;
Boolean* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant IsDeterministic(G)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Boolean>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant IsDeterministic(G)
    *(mP_0_1->CReference()) = IsDeterministic(*mP_0_0); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsEmptyLanguage*/
class Rti21IsEmptyLanguage : public Function { 
public:
Rti21IsEmptyLanguage(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti21IsEmptyLanguage(pFuncDef); };
protected:
Generator* mP_0_0;
Boolean* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Lm(GArg) == 0
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Boolean>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Lm(GArg) == 0
    *(mP_0_1->CReference()) = IsEmptyLanguage(*mP_0_0); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsNonblocking*/
class Rti22IsNonblocking : public Function { 
public:
Rti22IsNonblocking(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti22IsNonblocking(pFuncDef); };
protected:
Generator* mP_0_0;
Boolean* mP_0_1;
Generator* mP_1_0;
Generator* mP_1_1;
Boolean* mP_1_2;
GeneratorVector* mP_2_0;
Boolean* mP_2_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant IsNonblocking(G)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Boolean>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant IsNonblocking(G1,G2)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_1_1); break; 
    case 2:     res=DoTypeCast<Boolean>(2, mP_1_2); break; 
    default: break; 
    } 
    break; 
  } 
  case 2: { // variant IsNonblocking(G1,G2 ... Gn)
    switch(n) { 
    case 0:     res=DoTypeCast<GeneratorVector>(0, mP_2_0); break; 
    case 1:     res=DoTypeCast<Boolean>(1, mP_2_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant IsNonblocking(G)
    *(mP_0_1->CReference()) = IsNonblocking(*mP_0_0); break; };
  case 1: { // variant IsNonblocking(G1,G2)
    *(mP_1_2->CReference()) = IsNonblocking(*mP_1_0 ,*mP_1_1); break; };
  case 2: { // variant IsNonblocking(G1,G2 ... Gn)
    *(mP_2_1->CReference()) = IsNonblocking(*mP_2_0); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsOmegaClosed*/
class Rti23IsOmegaClosed : public Function { 
public:
Rti23IsOmegaClosed(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti23IsOmegaClosed(pFuncDef); };
protected:
Generator* mP_0_0;
Boolean* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant IsOmegaClosed(G)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Boolean>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant IsOmegaClosed(G)
    *(mP_0_1->CReference()) = IsOmegaClosed(*mP_0_0); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsOmegaTrim*/
class Rti24IsOmegaTrim : public Function { 
public:
Rti24IsOmegaTrim(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti24IsOmegaTrim(pFuncDef); };
protected:
Generator* mP_0_0;
Boolean* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Default
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Boolean>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Default
    *(mP_0_1->CReference()) = IsOmegaTrim(*mP_0_0); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsPrefixClosed*/
class Rti25IsPrefixClosed : public Function { 
public:
Rti25IsPrefixClosed(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti25IsPrefixClosed(pFuncDef); };
protected:
Generator* mP_0_0;
Boolean* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant IsPrefixClosed(G)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Boolean>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant IsPrefixClosed(G)
    *(mP_0_1->CReference()) = IsPrefixClosed(*mP_0_0); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsTrim*/
class Rti26IsTrim : public Function { 
public:
Rti26IsTrim(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti26IsTrim(pFuncDef); };
protected:
Generator* mP_0_0;
Boolean* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Default
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Boolean>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Default
    *(mP_0_1->CReference()) = IsTrim(*mP_0_0); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function KleeneClosure*/
class Rti27KleeneClosure : public Function { 
public:
Rti27KleeneClosure(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti27KleeneClosure(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_1_0;
Generator* mP_1_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Lm(G) := Lm(G)*
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant Lm(GRes) := Lm(GArg)*
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_1_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Lm(G) := Lm(G)*
    KleeneClosure(*mP_0_0); break; };
  case 1: { // variant Lm(GRes) := Lm(GArg)*
    KleeneClosure(*mP_1_0 ,*mP_1_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function LanguageComplement*/
class Rti28LanguageComplement : public Function { 
public:
Rti28LanguageComplement(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti28LanguageComplement(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_1_0;
Generator* mP_1_1;
Generator* mP_2_0;
EventSet* mP_2_1;
Generator* mP_2_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Lm(GPar) := -Lm(GPar)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant Lm(GRes) = -Lm(GArg)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_1_1); break; 
    default: break; 
    } 
    break; 
  } 
  case 2: { // variant Lm(GRes) = Sigma^* - Lm(GArg)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_2_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_2_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_2_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Lm(GPar) := -Lm(GPar)
    LanguageComplement(*mP_0_0); break; };
  case 1: { // variant Lm(GRes) = -Lm(GArg)
    LanguageComplement(*mP_1_0 ,*mP_1_1); break; };
  case 2: { // variant Lm(GRes) = Sigma^* - Lm(GArg)
    LanguageComplement(*mP_2_0 ,*mP_2_1 ,*mP_2_2); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function LanguageConcatenate*/
class Rti29LanguageConcatenate : public Function { 
public:
Rti29LanguageConcatenate(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti29LanguageConcatenate(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_0_1;
Generator* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Lm(GRes) = Lm(G1) Lm(G2)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Lm(GRes) = Lm(G1) Lm(G2)
    LanguageConcatenate(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function LanguageDifference*/
class Rti30LanguageDifference : public Function { 
public:
Rti30LanguageDifference(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti30LanguageDifference(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_0_1;
Generator* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Lm(GRes) = Lm(G1) - Lm(G2)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Lm(GRes) = Lm(G1) - Lm(G2)
    LanguageDifference(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function LanguageDisjoint*/
class Rti31LanguageDisjoint : public Function { 
public:
Rti31LanguageDisjoint(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti31LanguageDisjoint(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_0_1;
Boolean* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Lm(G1) ^ Lm(G2) == 0
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Boolean>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Lm(G1) ^ Lm(G2) == 0
    *(mP_0_2->CReference()) = LanguageDisjoint(*mP_0_0 ,*mP_0_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function LanguageEquality*/
class Rti32LanguageEquality : public Function { 
public:
Rti32LanguageEquality(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti32LanguageEquality(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_0_1;
Boolean* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Lm(G1) == Lm(G2)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Boolean>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Lm(G1) == Lm(G2)
    *(mP_0_2->CReference()) = LanguageEquality(*mP_0_0 ,*mP_0_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function LanguageInclusion*/
class Rti33LanguageInclusion : public Function { 
public:
Rti33LanguageInclusion(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti33LanguageInclusion(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_0_1;
Boolean* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Lm(G1) <= Lm(G2)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Boolean>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Lm(G1) <= Lm(G2)
    *(mP_0_2->CReference()) = LanguageInclusion(*mP_0_0 ,*mP_0_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function LanguageIntersection*/
class Rti34LanguageIntersection : public Function { 
public:
Rti34LanguageIntersection(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti34LanguageIntersection(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_0_1;
Generator* mP_0_2;
GeneratorVector* mP_1_0;
Generator* mP_1_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Lm(GRes) = Lm(G1) v Lm(G2)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant Lm(GRes) = ^_i(G_i)
    switch(n) { 
    case 0:     res=DoTypeCast<GeneratorVector>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_1_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Lm(GRes) = Lm(G1) v Lm(G2)
    LanguageIntersection(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  case 1: { // variant Lm(GRes) = ^_i(G_i)
    LanguageIntersection(*mP_1_0 ,*mP_1_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function LanguageUnion*/
class Rti35LanguageUnion : public Function { 
public:
Rti35LanguageUnion(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti35LanguageUnion(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_0_1;
Generator* mP_0_2;
GeneratorVector* mP_1_0;
Generator* mP_1_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Lm(GRes) = Lm(G1) v Lm(G2)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant Lm(GRes) = v_i(G_i)
    switch(n) { 
    case 0:     res=DoTypeCast<GeneratorVector>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_1_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Lm(GRes) = Lm(G1) v Lm(G2)
    LanguageUnion(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  case 1: { // variant Lm(GRes) = v_i(G_i)
    LanguageUnion(*mP_1_0 ,*mP_1_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function MarkAllStates*/
class Rti36MarkAllStates : public Function { 
public:
Rti36MarkAllStates(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti36MarkAllStates(pFuncDef); };
protected:
Generator* mP_0_0;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Mark(G)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Mark(G)
    MarkAllStates(*mP_0_0); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function OmegaClosure*/
class Rti37OmegaClosure : public Function { 
public:
Rti37OmegaClosure(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti37OmegaClosure(pFuncDef); };
protected:
Generator* mP_0_0;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant OmegaClosure(GArg)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant OmegaClosure(GArg)
    OmegaClosure(*mP_0_0); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function aOmegaParallel*/
class Rti38aOmegaParallel : public Function { 
public:
Rti38aOmegaParallel(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti38aOmegaParallel(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_0_1;
Generator* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant GRes = G1 || G2
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant GRes = G1 || G2
    aOmegaParallel(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function aOmegaProduct*/
class Rti39aOmegaProduct : public Function { 
public:
Rti39aOmegaProduct(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti39aOmegaProduct(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_0_1;
Generator* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant GRes = G1 xx G2
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant GRes = G1 xx G2
    aOmegaProduct(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function OmegaTrim*/
class Rti40OmegaTrim : public Function { 
public:
Rti40OmegaTrim(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti40OmegaTrim(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_1_0;
Generator* mP_1_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant G:=OmegaTrim(G)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant GRes=OmegaTrim(GArg)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_1_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant G:=OmegaTrim(G)
    OmegaTrim(*mP_0_0); break; };
  case 1: { // variant GRes=OmegaTrim(GArg)
    OmegaTrim(*mP_1_0 ,*mP_1_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function aParallel*/
class Rti41aParallel : public Function { 
public:
Rti41aParallel(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti41aParallel(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_0_1;
Generator* mP_0_2;
GeneratorVector* mP_1_0;
Generator* mP_1_1;
Generator* mP_2_0;
Generator* mP_2_1;
ProductCompositionMap* mP_2_2;
Generator* mP_2_3;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant GRes = G1 || G2
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant GRes = || G_i
    switch(n) { 
    case 0:     res=DoTypeCast<GeneratorVector>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_1_1); break; 
    default: break; 
    } 
    break; 
  } 
  case 2: { // variant Parallel with ComMap
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_2_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_2_1); break; 
    case 2:     res=DoTypeCast<ProductCompositionMap>(2, mP_2_2); break; 
    case 3:     res=DoTypeCast<Generator>(3, mP_2_3); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant GRes = G1 || G2
    aParallel(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  case 1: { // variant GRes = || G_i
    aParallel(*mP_1_0 ,*mP_1_1); break; };
  case 2: { // variant Parallel with ComMap
    aParallel(*mP_2_0 ,*mP_2_1 ,*mP_2_2 ,*mP_2_3); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function PrefixClosure*/
class Rti42PrefixClosure : public Function { 
public:
Rti42PrefixClosure(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti42PrefixClosure(pFuncDef); };
protected:
Generator* mP_0_0;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant PrefixClosure(GArg)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant PrefixClosure(GArg)
    PrefixClosure(*mP_0_0); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function aProduct*/
class Rti43aProduct : public Function { 
public:
Rti43aProduct(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti43aProduct(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_0_1;
Generator* mP_0_2;
Generator* mP_1_0;
Generator* mP_1_1;
ProductCompositionMap* mP_1_2;
Generator* mP_1_3;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant GRes = G1 x G2
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant Product with ComMap
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_1_1); break; 
    case 2:     res=DoTypeCast<ProductCompositionMap>(2, mP_1_2); break; 
    case 3:     res=DoTypeCast<Generator>(3, mP_1_3); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant GRes = G1 x G2
    aProduct(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  case 1: { // variant Product with ComMap
    aProduct(*mP_1_0 ,*mP_1_1 ,*mP_1_2 ,*mP_1_3); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function aProject*/
class Rti44aProject : public Function { 
public:
Rti44aProject(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti44aProject(pFuncDef); };
protected:
Generator* mP_0_0;
EventSet* mP_0_1;
Generator* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Project(G,Sigmal0,Res)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Project(G,Sigmal0,Res)
    aProject(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function SelfLoop*/
class Rti45SelfLoop : public Function { 
public:
Rti45SelfLoop(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti45SelfLoop(pFuncDef); };
protected:
Generator* mP_0_0;
EventSet* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant SelfLoop(G,Sigma)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant SelfLoop(G,Sigma)
    SelfLoop(*mP_0_0 ,*mP_0_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function aStateMin*/
class Rti46aStateMin : public Function { 
public:
Rti46aStateMin(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti46aStateMin(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_0_1;
Generator* mP_1_0;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant GRes:=StateMin(GArg)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant G:=StateMin(G)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant GRes:=StateMin(GArg)
    aStateMin(*mP_0_0 ,*mP_0_1); break; };
  case 1: { // variant G:=StateMin(G)
    aStateMin(*mP_1_0); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function Trim*/
class Rti47Trim : public Function { 
public:
Rti47Trim(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti47Trim(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_1_0;
Generator* mP_1_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant G:=Trim(G)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant GRes=Trim(GArg)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_1_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant G:=Trim(G)
    Trim(*mP_0_0); break; };
  case 1: { // variant GRes=Trim(GArg)
    Trim(*mP_1_0 ,*mP_1_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function UniqueInit*/
class Rti48UniqueInit : public Function { 
public:
Rti48UniqueInit(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti48UniqueInit(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_1_0;
Generator* mP_1_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant UniqueInit(G)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant UniqueInit(G,GRes)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_1_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant UniqueInit(G)
    UniqueInit(*mP_0_0); break; };
  case 1: { // variant UniqueInit(G,GRes)
    UniqueInit(*mP_1_0 ,*mP_1_1); break; };
  default: break; 
  }; 
}; 
};
} // namespace
