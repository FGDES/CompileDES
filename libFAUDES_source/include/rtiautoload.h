/* rti2code: autogenerated libFAUDES rti registration: libFAUDES 2.33l timed-iodevice-simulator */

namespace faudes {
void LoadRegisteredTypes(void);
} // namespace
namespace faudes {
void LoadRegisteredFunctions(void);
} // namespace
namespace faudes {
/* Function class for C++ function Accessible*/
class Rti0Accessible : public Function { 
public:
  using Function::operator=;
Rti0Accessible(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti0Accessible(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_1_0;
Generator* mP_1_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant G:=Acc(G)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant GRes:=Acc(GArg)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_1_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant G:=Acc(G)
    Accessible(*mP_0_0); break; };
  case 1: { // variant GRes:=Acc(GArg)
    Accessible(*mP_1_0 ,*mP_1_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function SetDifference*/
class Rti1SetDifference : public Function { 
public:
  using Function::operator=;
Rti1SetDifference(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti1SetDifference(pFuncDef); };
protected:
EventSet* mP_0_0;
EventSet* mP_0_1;
EventSet* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Sigma=Sigma1 - Sigma2
    switch(n) { 
    case 0:     res=DoTypeCast<EventSet>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<EventSet>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Sigma=Sigma1 - Sigma2
    SetDifference(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function SetEquality*/
class Rti2SetEquality : public Function { 
public:
  using Function::operator=;
Rti2SetEquality(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti2SetEquality(pFuncDef); };
protected:
EventSet* mP_0_0;
EventSet* mP_0_1;
Boolean* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Sigma1 == Sigma2
    switch(n) { 
    case 0:     res=DoTypeCast<EventSet>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Boolean>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Sigma1 == Sigma2
    *(mP_0_2->CReference()) = SetEquality(*mP_0_0 ,*mP_0_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function AlphabetExtract*/
class Rti3AlphabetExtract : public Function { 
public:
  using Function::operator=;
Rti3AlphabetExtract(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti3AlphabetExtract(pFuncDef); };
protected:
Generator* mP_0_0;
EventSet* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Sigma(Gen)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Sigma(Gen)
    AlphabetExtract(*mP_0_0 ,*mP_0_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function SetInclusion*/
class Rti4SetInclusion : public Function { 
public:
  using Function::operator=;
Rti4SetInclusion(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti4SetInclusion(pFuncDef); };
protected:
EventSet* mP_0_0;
EventSet* mP_0_1;
Boolean* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Sigma1 <= Sigma2
    switch(n) { 
    case 0:     res=DoTypeCast<EventSet>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Boolean>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Sigma1 <= Sigma2
    *(mP_0_2->CReference()) = SetInclusion(*mP_0_0 ,*mP_0_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function SetIntersection*/
class Rti5SetIntersection : public Function { 
public:
  using Function::operator=;
Rti5SetIntersection(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti5SetIntersection(pFuncDef); };
protected:
EventSet* mP_0_0;
EventSet* mP_0_1;
EventSet* mP_0_2;
EventSetVector* mP_1_0;
EventSet* mP_1_1;
GeneratorVector* mP_2_0;
EventSet* mP_2_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Sigma=Sigma1 ^ Sigma2
    switch(n) { 
    case 0:     res=DoTypeCast<EventSet>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<EventSet>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant Sigma = ^_i(Sigma_i)
    switch(n) { 
    case 0:     res=DoTypeCast<EventSetVector>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_1_1); break; 
    default: break; 
    } 
    break; 
  } 
  case 2: { // variant Sigma = ^_i(Sigma(Gen_i))
    switch(n) { 
    case 0:     res=DoTypeCast<GeneratorVector>(0, mP_2_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_2_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Sigma=Sigma1 ^ Sigma2
    SetIntersection(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  case 1: { // variant Sigma = ^_i(Sigma_i)
    SetIntersection(*mP_1_0 ,*mP_1_1); break; };
  case 2: { // variant Sigma = ^_i(Sigma(Gen_i))
    SetIntersection(*mP_2_0 ,*mP_2_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function AlphabetLanguage*/
class Rti6AlphabetLanguage : public Function { 
public:
  using Function::operator=;
Rti6AlphabetLanguage(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti6AlphabetLanguage(pFuncDef); };
protected:
EventSet* mP_0_0;
Generator* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Lm(GRes) = Sigma
    switch(n) { 
    case 0:     res=DoTypeCast<EventSet>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Lm(GRes) = Sigma
    AlphabetLanguage(*mP_0_0 ,*mP_0_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function SetUnion*/
class Rti7SetUnion : public Function { 
public:
  using Function::operator=;
Rti7SetUnion(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti7SetUnion(pFuncDef); };
protected:
EventSet* mP_0_0;
EventSet* mP_0_1;
EventSet* mP_0_2;
EventSetVector* mP_1_0;
EventSet* mP_1_1;
GeneratorVector* mP_2_0;
EventSet* mP_2_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Sigma=Sigma1 v Sigma2
    switch(n) { 
    case 0:     res=DoTypeCast<EventSet>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<EventSet>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant Sigma = v_i(Sigma_i)
    switch(n) { 
    case 0:     res=DoTypeCast<EventSetVector>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_1_1); break; 
    default: break; 
    } 
    break; 
  } 
  case 2: { // variant Sigma = v_i(Sigma(Gen_i))
    switch(n) { 
    case 0:     res=DoTypeCast<GeneratorVector>(0, mP_2_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_2_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Sigma=Sigma1 v Sigma2
    SetUnion(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  case 1: { // variant Sigma = v_i(Sigma_i)
    SetUnion(*mP_1_0 ,*mP_1_1); break; };
  case 2: { // variant Sigma = v_i(Sigma(Gen_i))
    SetUnion(*mP_2_0 ,*mP_2_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function ApplyRelabelMap*/
class Rti8ApplyRelabelMap : public Function { 
public:
  using Function::operator=;
Rti8ApplyRelabelMap(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti8ApplyRelabelMap(pFuncDef); };
protected:
RelabelMap* mP_0_0;
EventSet* mP_0_1;
EventSet* mP_0_2;
RelabelMap* mP_1_0;
TransSet* mP_1_1;
TransSet* mP_1_2;
RelabelMap* mP_2_0;
Generator* mP_2_1;
Generator* mP_2_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant ApplyRelableMap(map,sigma,sigma)
    switch(n) { 
    case 0:     res=DoTypeCast<RelabelMap>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<EventSet>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant ApplyRelableMap(map,delta,delta)
    switch(n) { 
    case 0:     res=DoTypeCast<RelabelMap>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<TransSet>(1, mP_1_1); break; 
    case 2:     res=DoTypeCast<TransSet>(2, mP_1_2); break; 
    default: break; 
    } 
    break; 
  } 
  case 2: { // variant ApplyRelableMap(map,gen,gen)
    switch(n) { 
    case 0:     res=DoTypeCast<RelabelMap>(0, mP_2_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_2_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_2_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant ApplyRelableMap(map,sigma,sigma)
    ApplyRelabelMap(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  case 1: { // variant ApplyRelableMap(map,delta,delta)
    ApplyRelabelMap(*mP_1_0 ,*mP_1_1 ,*mP_1_2); break; };
  case 2: { // variant ApplyRelableMap(map,gen,gen)
    ApplyRelabelMap(*mP_2_0 ,*mP_2_1 ,*mP_2_2); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function Automaton*/
class Rti9Automaton : public Function { 
public:
  using Function::operator=;
Rti9Automaton(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti9Automaton(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_1_0;
EventSet* mP_1_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Automaton(GArg)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant Automaton(GArg, Sigma)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_1_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Automaton(GArg)
    Automaton(*mP_0_0); break; };
  case 1: { // variant Automaton(GArg, Sigma)
    Automaton(*mP_1_0 ,*mP_1_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function Coaccessible*/
class Rti10Coaccessible : public Function { 
public:
  using Function::operator=;
Rti10Coaccessible(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti10Coaccessible(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_1_0;
Generator* mP_1_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant G:=CoAcc(G)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant GRes:=CoAcc(GArg)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_1_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant G:=CoAcc(G)
    Coaccessible(*mP_0_0); break; };
  case 1: { // variant GRes:=CoAcc(GArg)
    Coaccessible(*mP_1_0 ,*mP_1_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function Complete*/
class Rti11Complete : public Function { 
public:
  using Function::operator=;
Rti11Complete(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti11Complete(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_1_0;
Generator* mP_1_1;
Generator* mP_2_0;
EventSet* mP_2_1;
Generator* mP_3_0;
EventSet* mP_3_1;
Generator* mP_3_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant G:=Complete(G)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant GRes:=Complete(G)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_1_1); break; 
    default: break; 
    } 
    break; 
  } 
  case 2: { // variant G:=Complete(G,SigmaO)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_2_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_2_1); break; 
    default: break; 
    } 
    break; 
  } 
  case 3: { // variant GRes:=Complete(G,SigmaO)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_3_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_3_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_3_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant G:=Complete(G)
    Complete(*mP_0_0); break; };
  case 1: { // variant GRes:=Complete(G)
    Complete(*mP_1_0 ,*mP_1_1); break; };
  case 2: { // variant G:=Complete(G,SigmaO)
    Complete(*mP_2_0 ,*mP_2_1); break; };
  case 3: { // variant GRes:=Complete(G,SigmaO)
    Complete(*mP_3_0 ,*mP_3_1 ,*mP_3_2); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function aDeterministic*/
class Rti12aDeterministic : public Function { 
public:
  using Function::operator=;
Rti12aDeterministic(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti12aDeterministic(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Deterministic(G,GRes)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Deterministic(G,GRes)
    aDeterministic(*mP_0_0 ,*mP_0_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function EmptyLanguage*/
class Rti13EmptyLanguage : public Function { 
public:
  using Function::operator=;
Rti13EmptyLanguage(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti13EmptyLanguage(pFuncDef); };
protected:
EventSet* mP_0_0;
Generator* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Lm(GRes) := 0
    switch(n) { 
    case 0:     res=DoTypeCast<EventSet>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Lm(GRes) := 0
    EmptyLanguage(*mP_0_0 ,*mP_0_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function EmptyStringLanguage*/
class Rti14EmptyStringLanguage : public Function { 
public:
  using Function::operator=;
Rti14EmptyStringLanguage(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti14EmptyStringLanguage(pFuncDef); };
protected:
EventSet* mP_0_0;
Generator* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Lm(GRes) = {epsilon}
    switch(n) { 
    case 0:     res=DoTypeCast<EventSet>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Lm(GRes) = {epsilon}
    EmptyStringLanguage(*mP_0_0 ,*mP_0_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function FullLanguage*/
class Rti15FullLanguage : public Function { 
public:
  using Function::operator=;
Rti15FullLanguage(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti15FullLanguage(pFuncDef); };
protected:
EventSet* mP_0_0;
Generator* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant L(GRes) = Sigma*
    switch(n) { 
    case 0:     res=DoTypeCast<EventSet>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant L(GRes) = Sigma*
    FullLanguage(*mP_0_0 ,*mP_0_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IntegerSum*/
class Rti16IntegerSum : public Function { 
public:
  using Function::operator=;
Rti16IntegerSum(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti16IntegerSum(pFuncDef); };
protected:
Integer* mP_0_0;
Integer* mP_0_1;
Integer* mP_0_2;
IntegerVector* mP_1_0;
Integer* mP_1_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant IRes=I_1+I_2
    switch(n) { 
    case 0:     res=DoTypeCast<Integer>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Integer>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Integer>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant IRes=Sum_i I_i
    switch(n) { 
    case 0:     res=DoTypeCast<IntegerVector>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<Integer>(1, mP_1_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant IRes=I_1+I_2
    *(mP_0_2->CReference()) = IntegerSum(*(mP_0_0->CReference()) ,*(mP_0_1->CReference())); break; };
  case 1: { // variant IRes=Sum_i I_i
    *(mP_1_1->CReference()) = IntegerSum(*mP_1_0); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function aInvProject*/
class Rti17aInvProject : public Function { 
public:
  using Function::operator=;
Rti17aInvProject(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti17aInvProject(pFuncDef); };
protected:
Generator* mP_0_0;
EventSet* mP_0_1;
Generator* mP_1_0;
EventSet* mP_1_1;
Generator* mP_1_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant InvProject(G0,Sigma)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant InvProject(G0,Sigma,GRes)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_1_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_1_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant InvProject(G0,Sigma)
    aInvProject(*mP_0_0 ,*mP_0_1); break; };
  case 1: { // variant InvProject(G0,Sigma,GRes)
    aInvProject(*mP_1_0 ,*mP_1_1 ,*mP_1_2); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsAccessible*/
class Rti18IsAccessible : public Function { 
public:
  using Function::operator=;
Rti18IsAccessible(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti18IsAccessible(pFuncDef); };
protected:
Generator* mP_0_0;
Boolean* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Default
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Boolean>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Default
    *(mP_0_1->CReference()) = IsAccessible(*mP_0_0); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsClosed*/
class Rti19IsClosed : public Function { 
public:
  using Function::operator=;
Rti19IsClosed(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti19IsClosed(pFuncDef); };
protected:
Generator* mP_0_0;
Boolean* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant IsClosed(G)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Boolean>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant IsClosed(G)
    *(mP_0_1->CReference()) = IsClosed(*mP_0_0); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsCoaccessible*/
class Rti20IsCoaccessible : public Function { 
public:
  using Function::operator=;
Rti20IsCoaccessible(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti20IsCoaccessible(pFuncDef); };
protected:
Generator* mP_0_0;
Boolean* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Default
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Boolean>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Default
    *(mP_0_1->CReference()) = IsCoaccessible(*mP_0_0); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsComplete*/
class Rti21IsComplete : public Function { 
public:
  using Function::operator=;
Rti21IsComplete(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti21IsComplete(pFuncDef); };
protected:
Generator* mP_0_0;
Boolean* mP_0_1;
Generator* mP_1_0;
EventSet* mP_1_1;
Boolean* mP_1_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant IsComplete(G)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Boolean>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant IsComplete(G,SigmaO)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_1_1); break; 
    case 2:     res=DoTypeCast<Boolean>(2, mP_1_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant IsComplete(G)
    *(mP_0_1->CReference()) = IsComplete(*mP_0_0); break; };
  case 1: { // variant IsComplete(G,SigmaO)
    *(mP_1_2->CReference()) = IsComplete(*mP_1_0 ,*mP_1_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsDeterministic*/
class Rti22IsDeterministic : public Function { 
public:
  using Function::operator=;
Rti22IsDeterministic(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti22IsDeterministic(pFuncDef); };
protected:
Generator* mP_0_0;
Boolean* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant IsDeterministic(G)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Boolean>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant IsDeterministic(G)
    *(mP_0_1->CReference()) = IsDeterministic(*mP_0_0); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsEmptyLanguage*/
class Rti23IsEmptyLanguage : public Function { 
public:
  using Function::operator=;
Rti23IsEmptyLanguage(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti23IsEmptyLanguage(pFuncDef); };
protected:
Generator* mP_0_0;
Boolean* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Lm(GArg) == 0
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Boolean>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Lm(GArg) == 0
    *(mP_0_1->CReference()) = IsEmptyLanguage(*mP_0_0); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsNonblocking*/
class Rti24IsNonblocking : public Function { 
public:
  using Function::operator=;
Rti24IsNonblocking(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti24IsNonblocking(pFuncDef); };
protected:
Generator* mP_0_0;
Boolean* mP_0_1;
Generator* mP_1_0;
Generator* mP_1_1;
Boolean* mP_1_2;
GeneratorVector* mP_2_0;
Boolean* mP_2_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant IsNonblocking(G)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Boolean>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant IsNonblocking(G1,G2)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_1_1); break; 
    case 2:     res=DoTypeCast<Boolean>(2, mP_1_2); break; 
    default: break; 
    } 
    break; 
  } 
  case 2: { // variant IsNonblocking(G1,G2 ... Gn)
    switch(n) { 
    case 0:     res=DoTypeCast<GeneratorVector>(0, mP_2_0); break; 
    case 1:     res=DoTypeCast<Boolean>(1, mP_2_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant IsNonblocking(G)
    *(mP_0_1->CReference()) = IsNonblocking(*mP_0_0); break; };
  case 1: { // variant IsNonblocking(G1,G2)
    *(mP_1_2->CReference()) = IsNonblocking(*mP_1_0 ,*mP_1_1); break; };
  case 2: { // variant IsNonblocking(G1,G2 ... Gn)
    *(mP_2_1->CReference()) = IsNonblocking(*mP_2_0); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsTrim*/
class Rti25IsTrim : public Function { 
public:
  using Function::operator=;
Rti25IsTrim(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti25IsTrim(pFuncDef); };
protected:
Generator* mP_0_0;
Boolean* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Default
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Boolean>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Default
    *(mP_0_1->CReference()) = IsTrim(*mP_0_0); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function KleeneClosure*/
class Rti26KleeneClosure : public Function { 
public:
  using Function::operator=;
Rti26KleeneClosure(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti26KleeneClosure(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_1_0;
Generator* mP_1_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Lm(G) := Lm(G)*
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant Lm(GRes) := Lm(GArg)*
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_1_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Lm(G) := Lm(G)*
    KleeneClosure(*mP_0_0); break; };
  case 1: { // variant Lm(GRes) := Lm(GArg)*
    KleeneClosure(*mP_1_0 ,*mP_1_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function LanguageComplement*/
class Rti27LanguageComplement : public Function { 
public:
  using Function::operator=;
Rti27LanguageComplement(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti27LanguageComplement(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_1_0;
Generator* mP_1_1;
Generator* mP_2_0;
EventSet* mP_2_1;
Generator* mP_2_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Lm(GPar) := -Lm(GPar)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant Lm(GRes) = -Lm(GArg)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_1_1); break; 
    default: break; 
    } 
    break; 
  } 
  case 2: { // variant Lm(GRes) = Sigma^* - Lm(GArg)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_2_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_2_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_2_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Lm(GPar) := -Lm(GPar)
    LanguageComplement(*mP_0_0); break; };
  case 1: { // variant Lm(GRes) = -Lm(GArg)
    LanguageComplement(*mP_1_0 ,*mP_1_1); break; };
  case 2: { // variant Lm(GRes) = Sigma^* - Lm(GArg)
    LanguageComplement(*mP_2_0 ,*mP_2_1 ,*mP_2_2); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function LanguageConcatenate*/
class Rti28LanguageConcatenate : public Function { 
public:
  using Function::operator=;
Rti28LanguageConcatenate(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti28LanguageConcatenate(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_0_1;
Generator* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Lm(GRes) = Lm(G1) Lm(G2)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Lm(GRes) = Lm(G1) Lm(G2)
    LanguageConcatenate(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function LanguageDifference*/
class Rti29LanguageDifference : public Function { 
public:
  using Function::operator=;
Rti29LanguageDifference(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti29LanguageDifference(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_0_1;
Generator* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Lm(GRes) = Lm(G1) - Lm(G2)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Lm(GRes) = Lm(G1) - Lm(G2)
    LanguageDifference(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function LanguageDisjoint*/
class Rti30LanguageDisjoint : public Function { 
public:
  using Function::operator=;
Rti30LanguageDisjoint(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti30LanguageDisjoint(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_0_1;
Boolean* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Lm(G1) ^ Lm(G2) == 0
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Boolean>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Lm(G1) ^ Lm(G2) == 0
    *(mP_0_2->CReference()) = LanguageDisjoint(*mP_0_0 ,*mP_0_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function LanguageEquality*/
class Rti31LanguageEquality : public Function { 
public:
  using Function::operator=;
Rti31LanguageEquality(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti31LanguageEquality(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_0_1;
Boolean* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Lm(G1) == Lm(G2)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Boolean>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Lm(G1) == Lm(G2)
    *(mP_0_2->CReference()) = LanguageEquality(*mP_0_0 ,*mP_0_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function LanguageInclusion*/
class Rti32LanguageInclusion : public Function { 
public:
  using Function::operator=;
Rti32LanguageInclusion(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti32LanguageInclusion(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_0_1;
Boolean* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Lm(G1) <= Lm(G2)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Boolean>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Lm(G1) <= Lm(G2)
    *(mP_0_2->CReference()) = LanguageInclusion(*mP_0_0 ,*mP_0_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function LanguageIntersection*/
class Rti33LanguageIntersection : public Function { 
public:
  using Function::operator=;
Rti33LanguageIntersection(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti33LanguageIntersection(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_0_1;
Generator* mP_0_2;
GeneratorVector* mP_1_0;
Generator* mP_1_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Lm(GRes) = Lm(G1) v Lm(G2)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant Lm(GRes) = ^_i(G_i)
    switch(n) { 
    case 0:     res=DoTypeCast<GeneratorVector>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_1_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Lm(GRes) = Lm(G1) v Lm(G2)
    LanguageIntersection(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  case 1: { // variant Lm(GRes) = ^_i(G_i)
    LanguageIntersection(*mP_1_0 ,*mP_1_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function LanguageUnion*/
class Rti34LanguageUnion : public Function { 
public:
  using Function::operator=;
Rti34LanguageUnion(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti34LanguageUnion(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_0_1;
Generator* mP_0_2;
GeneratorVector* mP_1_0;
Generator* mP_1_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Lm(GRes) = Lm(G1) v Lm(G2)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant Lm(GRes) = v_i(G_i)
    switch(n) { 
    case 0:     res=DoTypeCast<GeneratorVector>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_1_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Lm(GRes) = Lm(G1) v Lm(G2)
    LanguageUnion(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  case 1: { // variant Lm(GRes) = v_i(G_i)
    LanguageUnion(*mP_1_0 ,*mP_1_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function MarkAllStates*/
class Rti35MarkAllStates : public Function { 
public:
  using Function::operator=;
Rti35MarkAllStates(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti35MarkAllStates(pFuncDef); };
protected:
Generator* mP_0_0;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Mark(G)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Mark(G)
    MarkAllStates(*mP_0_0); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function aParallel*/
class Rti36aParallel : public Function { 
public:
  using Function::operator=;
Rti36aParallel(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti36aParallel(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_0_1;
Generator* mP_0_2;
GeneratorVector* mP_1_0;
Generator* mP_1_1;
Generator* mP_2_0;
Generator* mP_2_1;
ProductCompositionMap* mP_2_2;
Generator* mP_2_3;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant GRes = G1 || G2
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant GRes = || G_i
    switch(n) { 
    case 0:     res=DoTypeCast<GeneratorVector>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_1_1); break; 
    default: break; 
    } 
    break; 
  } 
  case 2: { // variant Parallel with ComMap
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_2_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_2_1); break; 
    case 2:     res=DoTypeCast<ProductCompositionMap>(2, mP_2_2); break; 
    case 3:     res=DoTypeCast<Generator>(3, mP_2_3); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant GRes = G1 || G2
    aParallel(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  case 1: { // variant GRes = || G_i
    aParallel(*mP_1_0 ,*mP_1_1); break; };
  case 2: { // variant Parallel with ComMap
    aParallel(*mP_2_0 ,*mP_2_1 ,*mP_2_2 ,*mP_2_3); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function ParallelLive*/
class Rti37ParallelLive : public Function { 
public:
  using Function::operator=;
Rti37ParallelLive(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti37ParallelLive(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_0_1;
Generator* mP_0_2;
GeneratorVector* mP_1_0;
Generator* mP_1_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant GRes = G1 || G2
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant GRes = || G_i
    switch(n) { 
    case 0:     res=DoTypeCast<GeneratorVector>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_1_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant GRes = G1 || G2
    ParallelLive(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  case 1: { // variant GRes = || G_i
    ParallelLive(*mP_1_0 ,*mP_1_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function PrefixClosure*/
class Rti38PrefixClosure : public Function { 
public:
  using Function::operator=;
Rti38PrefixClosure(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti38PrefixClosure(pFuncDef); };
protected:
Generator* mP_0_0;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant PrefixClosure(GArg)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant PrefixClosure(GArg)
    PrefixClosure(*mP_0_0); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function aProduct*/
class Rti39aProduct : public Function { 
public:
  using Function::operator=;
Rti39aProduct(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti39aProduct(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_0_1;
Generator* mP_0_2;
Generator* mP_1_0;
Generator* mP_1_1;
ProductCompositionMap* mP_1_2;
Generator* mP_1_3;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant GRes = G1 x G2
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant Product with ComMap
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_1_1); break; 
    case 2:     res=DoTypeCast<ProductCompositionMap>(2, mP_1_2); break; 
    case 3:     res=DoTypeCast<Generator>(3, mP_1_3); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant GRes = G1 x G2
    aProduct(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  case 1: { // variant Product with ComMap
    aProduct(*mP_1_0 ,*mP_1_1 ,*mP_1_2 ,*mP_1_3); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function aProject*/
class Rti40aProject : public Function { 
public:
  using Function::operator=;
Rti40aProject(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti40aProject(pFuncDef); };
protected:
Generator* mP_0_0;
EventSet* mP_0_1;
Generator* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Project(G,Sigmal0,Res)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Project(G,Sigmal0,Res)
    aProject(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function SelfLoop*/
class Rti41SelfLoop : public Function { 
public:
  using Function::operator=;
Rti41SelfLoop(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti41SelfLoop(pFuncDef); };
protected:
Generator* mP_0_0;
EventSet* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant SelfLoop(G,Sigma)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant SelfLoop(G,Sigma)
    SelfLoop(*mP_0_0 ,*mP_0_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function aStateMin*/
class Rti42aStateMin : public Function { 
public:
  using Function::operator=;
Rti42aStateMin(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti42aStateMin(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_0_1;
Generator* mP_1_0;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant GRes:=StateMin(GArg)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant G:=StateMin(G)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant GRes:=StateMin(GArg)
    aStateMin(*mP_0_0 ,*mP_0_1); break; };
  case 1: { // variant G:=StateMin(G)
    aStateMin(*mP_1_0); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function Trim*/
class Rti43Trim : public Function { 
public:
  using Function::operator=;
Rti43Trim(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti43Trim(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_1_0;
Generator* mP_1_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant G:=Trim(G)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant GRes=Trim(GArg)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_1_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant G:=Trim(G)
    Trim(*mP_0_0); break; };
  case 1: { // variant GRes=Trim(GArg)
    Trim(*mP_1_0 ,*mP_1_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function UniqueInit*/
class Rti44UniqueInit : public Function { 
public:
  using Function::operator=;
Rti44UniqueInit(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti44UniqueInit(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_1_0;
Generator* mP_1_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant UniqueInit(G)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant UniqueInit(G,GRes)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_1_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant UniqueInit(G)
    UniqueInit(*mP_0_0); break; };
  case 1: { // variant UniqueInit(G,GRes)
    UniqueInit(*mP_1_0 ,*mP_1_1); break; };
  default: break; 
  }; 
}; 
};
} // namespace
