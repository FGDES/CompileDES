/** @file cgp_iec61131st.h @brief Code-generator for target IEC 61131-3 ST */

/*
  FAU Discrete Event Systems Library (libFAUDES)

  Copyright (C) 2010, 2016, 2017 Thomas Moor

*/



#ifndef FAUDES_IEC61131stCode_H
#define FAUDES_IEC61131stCode_H

#include "libfaudes.h"
#include "cgp_codeprimitives.h"

using namespace faudes;



/**
 * @brief Implementation of primitives by IEC 61131 ST
 *
 * This class generates code for generic IEC 61131-3 Structured Text targets.
 * Since ST is a high-level language and offers all relevant constructs natively,
 * implementation of individual code primitives is straight forward.
 *
 * The generated output consists of a single ASCII-encoded file, intended for cut-and-paste
 * insertion into an IEC IDE. The derived class PlcoxmlCodeGenerator provides an alternative
 * XML-encoded output.
 *
 * Regarding top-level code organisation, Iec61131stCodeGenerator produces one
 * IEC <tt>FUNCTION_BLOCK</tt> for cyclic invocation by the host application.
 * It accepts the optional input <tt>RESET</tt> for manual reset and it provides
 * the output variable <tt>STATUS</tt> with bit 0 for busy and
 * bit 1 for event synchronisation error, respectively. Optionally, there are the additional output variables
 * <tt>RECENT_EVENT</tt> and <tt>PARALLEL_STATE</tt> for diagnosis purposes.
 *
 * The following additional code-options are supported.
 *
 * <strong>IecIncludeCyclic</strong>. This option specifies additional code to be
 * inserted just after the variable declarations of the cyclic function block. The intended use case is to
 * instantiate function blocks used in execute actions. Note also the inherited options
 * <strong>IncludeBefore</strong> and <strong>IecIncludeAfter</strong> if you want to add
 * additional program organisation units, e.g., an IEC <tt>PROGRAM</tt> that invokes the
 * cyclic function block.
 *
 * @verbatim
   <IecIncludeCyclic>
   <![CDATA[
    [... insert code here ...]
   ]]>
   </IecIncludeCyclic>
   @endverbatim
 *
 * <strong>IecDeclarePhysical</strong>. This option specifies the declaration keyword
 * for the import of physical i/o addresses. The default is <tt>VAR_EXTERNAL</tt>, however,
 * some compilers insist in a plain <tt>VAR</tt>. To disable explicit declaration of physical i/o alltogether,
 * set this option to the empty string.
 *
 * @verbatim
   <IecDeclarePhysical val="VAR_EXTERNAL"/>
   @endverbatim
 *
 * <strong>IecTimeOperators</strong>. The default is to use explicit functions for artithmetic with
 * time date, i.e., <tt>SUB_TIME</tt> and <tt>ADD_TIME</tt>. This is IEC compliant. However, some target platforms do not provide
 * these functions but insist in appropriatly overloaded binary operators <tt>+</tt> and <tt>-</tt>. Corresponding
 * code will be generated by setting this option <tt>true</tt>.
 *
 * @verbatim
   <IecTimeOperators val="true"/>
   @endverbatim
 *
 * Example of generated code
 * @code
(* code inserted by configuration via IncludeBefore *)
PROGRAM main

VAR
  stat   : INT :=0;
  cyclic : PREFIX_cyclic_fb;
END_VAR

cyclic(STATUS => stat);

END_PROGRAM
(* end of configuration code *)


FUNCTION_BLOCK PREFIX_cyclic_fb

(* local variables *)
VAR
[.. generated variables, all with PREFIX_ ..]
END_VAR

(* declare physical addresses relevant for io *)
VAR
[.. generated, all of the form AT %xyz.a.b.c ..]
END_VAR

(* code inserted via IncludeCyclic goes here*)

[.. generated core cyclic code by code primitives ..]

END_FUNCTION_BLOCK (* end of fcg_cyclic_fb *)
@endcode
 *
 *
 *See @ref blink_geb.cgc for an self-contained example.
 *
 *
 *
 * @ingroup CGClasses
 */

class Iec61131stCodeGenerator : public CodePrimitives {

public:

  /*****************************************
   *****************************************
   *****************************************
   *****************************************/
  enum IECVariableType { LOCAL, TEMP, INPUT, OUTPUT, INOUT, EXTERNAL, GLOBAL, ACCESS, NONE };


  /** @name Basic Class Maintenance */
  /** @{ */

  /**
   * @brief Constructor
   */
  Iec61131stCodeGenerator(void);

  /**
   * @brief Explicit destructor.
   */
  virtual ~Iec61131stCodeGenerator(void);


  /**
   * @brief Clear all data.
   *
   */
  virtual void Clear(void);


  /** @}  */

protected:

  /*! option: formal declaration of io lines */
  std::string mIecDeclarePhysical;

  /*! option: overloaded operators for time maths */
  bool mHasIecTimeOperators;

  /*! option: extra cyclic code */
  std::string mLiteralCyclic;

  /*! add my preferences to DoCompile */
  void DoCompile(void);

  /*! code generation hook (overall) */
  void DoGenerate(void);

  /*! code generation hook (function block) */
  virtual void DoGenerateFunction(void);

  /*! code generation hook (lookup functions) */
  virtual void DoGenerateLookups(void);

  /*! code snippet */
  virtual void DecrementTimers(void);

  /*! reimplemented code snippets */
  void BeginCyclicCode(void);

  /*! reimplemented code snippets */
  void EndCyclicCode(void);

  /*! abstract address conversion */
  virtual std::string TargetAddress(const AA& address);

  /*! abstract address conversion */
  virtual AX TargetExpression(const AA& address);


  /** @name Implement Primitives
   *
   */
   /** @{ */

   /* re-implement primitives */
  virtual void Comment(const std::string& text);

  /* re-implement primitives */
  virtual void VariableDeclare(const std::string& laddr, const std::string& ltype);
  virtual void VariableDeclare(const std::string& laddr, const std::string& ltype, const std::string& lval);

  /* re-implement primitives */
  virtual void IntegerDeclare(const AA& address);
  virtual void IntegerDeclare(const AA& address, int val);
  virtual void IntegerAssign(const AA& address, int val);
  virtual void IntegerAssign(const AA& address, const AX& expression);
  virtual void IntegerIncrement(const AA& address, int val);
  virtual AX IntegerQuotient(const AX& expression, int val);
  virtual AX IntegerRemainder(const AX& expression, int val);
  virtual AX IntegerBitmask(const AX& expression);
  virtual AX IntegerIsEq(const AA& address, int val);
  virtual AX IntegerIsEq(const AA& address, const AX& expression);
  virtual AX IntegerIsNotEq(const AA& address, int val);
  virtual AX IntegerIsNotEq(const AA& address, const AX& expression);
  virtual AX IntegerIsGreater(const AA& address, int val);
  virtual AX IntegerIsLess(const AA& address, int val);
  virtual AX IntegerConstant(int val);

  /* re-implement primitives */
  virtual bool HasIntmaths(void);
  virtual void WordDeclare(const AA& address);
  virtual void WordDeclare(const AA& address, word_t val);
  virtual void WordAssign(const AA& address, word_t val);
  virtual void WordAssign(const AA& address, const AX& expression);
  virtual void WordOr(const AA& address, word_t val);
  virtual void WordOr(const AA& address, const AX& expression);
  virtual void WordOr(const AA& address, const AA& op1, const AA& op2);
  virtual void WordOr(const AA& address, const AA& op1, word_t op2);
  virtual void WordAnd(const AA& address, word_t val);
  virtual void WordAnd(const AA& address, const AX& expression);
  virtual void WordAnd(const AA& address, const AA& op1, const AA& op2);
  virtual void WordAnd(const AA& address, const AA& op1, word_t op2);
  virtual void WordNand(const AA& address, const AX& expression);
  virtual AX WordIsBitSet(const AA& address, int idx);
  virtual AX WordIsBitClr(const AA& address, int idx);
  virtual AX WordIsMaskSet(const AA& address, word_t mask);
  virtual AX WordIsEq(const AA& address, word_t val);
  virtual AX WordIsNotEq(const AA& address, word_t val);
  virtual AX WordConstant(word_t val);

  /* re-implement primitives */
  virtual void BooleanDeclare(const AA& address);
  virtual void BooleanDeclare(const AA& address, int val);
  virtual void BooleanAssign(const AA& address, int val);
  virtual void BooleanAssign(const AA& address, const AX& expression);
  virtual AX BooleanIsEq(const AA& op1, const AA& op2);
  virtual AX BooleanIsNotEq(const AA& op1, const AA& op2);

  /* re-implement primitives */
  virtual void CintarrayDeclare(const AA& address, int offset, const std::vector<int>& val);
  virtual AA CintarrayAccess(const AA& address, int index);
  virtual AA CintarrayAccess(const AA& address, const AA& indexaddr);
  virtual bool HasCintarray(void);
  virtual void CwordarrayDeclare(const AA& address, int offset, const std::vector<word_t>& val);
  virtual AA CwordarrayAccess(const AA& address, int index);
  virtual AA CwordarrayAccess(const AA& address, const AA& indexaddr);
  virtual bool HasCwordarray(void);
  virtual void CstrarrayDeclare(const AA& address, int offset, const std::vector<std::string>& val);
  virtual AA CstrarrayAccess(const AA& address, int index);
  virtual AA CstrarrayAccess(const AA& address, const AA& indexaddr);
  virtual bool HasCstrarray(void);
  virtual void IntarrayDeclare(const AA& address, int offset, int len);
  virtual void IntarrayDeclare(const AA& address, int offset, const std::vector<int>& val);
  virtual AA IntarrayAccess(const AA& address, int index);
  virtual AA IntarrayAccess(const AA& address, const AA& indexaddr);
  virtual bool HasIntarray(void);
  virtual void WordarrayDeclare(const AA& address, int offset, int len);
  virtual void WordarrayDeclare(const AA& address, int offset, const std::vector<word_t>& val);
  virtual AA WordarrayAccess(const AA& address, int index);
  virtual AA WordarrayAccess(const AA& address, const AA& indexaddr);
  virtual bool HasWordarray(void);


  /* re-implement primitives */
  virtual void IfTrue(const AX& expression);
  virtual void IfFalse(const AX& expression);
  virtual void IfWord(const AX& expression);
  virtual void IfElse(void);
  virtual void IfElseIfTrue(const AX& expression);
  virtual void IfEnd(void);

  /* re-implement primitives */
  virtual void SwitchBegin(const AA& address);
  virtual void SwitchCase(const AA& address, int val);
  virtual void SwitchCases(const AA& address, int from, int to);
  virtual void SwitchCases(const AA& address, const std::set< int >& vals);
  virtual void SwitchBreak(void);
  virtual void SwitchEnd(void);
  virtual bool HasMultiCase(void);

  /* re-implement primitives */
  virtual void LoopBegin(void);
  virtual void LoopBreak(const AX& expression);
  virtual void LoopEnd(void);
  virtual void FunctionReturn(void);


  /* re-implement primitives */
  virtual void RunActionSet(const std::string& address);
  virtual void RunActionClr(const std::string& address);
  virtual void RunActionExe(const AX& expression);

  /* re-implement primitives */
  virtual void TimerDeclare(const AA& address, const std::string& val);
  virtual void TimerStart(const AA& address);
  virtual void TimerStop(const AA& address);
  virtual void TimerReset(const AA& address, const std::string& val);
  virtual AX TimerIsElapsed(const AA& address);

  /* re-implement primitives */
  virtual void DeclareTimers(void);
  virtual void ResetState(void);


  /* code generator primitives, iec-specific helper */
  virtual AX TimeConstant(int val);
  virtual AX IntarrayConstant(const std::vector<int>& val);
  virtual AX WordarrayConstant(const std::vector<word_t>& val);
  virtual AX StringConstant(const std::string& val);
  virtual AX StrarrayConstant(const std::vector<std::string>& val);

  virtual void DeclareImportPhysicalIo(void);
  virtual void DeclareImportSymbolicIo(void);
  virtual int CountImportPhysicalIo(void);
  virtual int CountImportSymbolicIo(void);
  virtual void LiteralCyclic(void);
  virtual void DeclareSystime(void);
  virtual void UpdateSystime(void);
  virtual void InsertExecHooks(void);



  /** @} */


  /**
   * @brief File i/o
   *
   * Reads global configuration from TokenReader, excl. label
   *
   * @param rTr
   *   TokenReader to read from
   *
   * @exception Exception
   *   - token mismatch (id 502)
   *   - IO error (id 1)
   */
  virtual void DoReadTargetConfiguration(TokenReader& rTr);

  /**
   * @brief File i/o
   *
   * Write global configuration to TokenWriter, excl. label
   *
   * @param rTw
   *   Reference to TokenWriter
   *
   * @exception Exception
   *   - IO errors (id 2)
   */
  virtual void DoWriteTargetConfiguration(TokenWriter& rTw) const;

  void CurrentVariableType(const IECVariableType& type);
  IECVariableType CurrentVariableType(void);

private:
  IECVariableType mCurrentVariableType;
  bool mDeclareIOVars;

};


#endif
