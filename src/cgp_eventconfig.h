/** @file cgp_eventconfig.h @brief Event attributes (execution semantics)  */


/*
  FAU Discrete Event Systems Library (libFAUDES)

  Copyright (C) 2010, 2016 Thomas Moor

*/



#ifndef FAUDES_CGP_EVENTCONF_H
#define FAUDES_CGP_EVENTCONF_H

#include "libfaudes.h"

using namespace faudes;


//#define FAUDES_DEBUG_CODEGEN

// debugging
#ifdef FAUDES_DEBUG_CODEGEN
#define FD_DCG(message) FAUDES_WRITE_CONSOLE("FAUDES_CODEGENERATOR: " << message)
#else
#define FD_DCG(message)
#endif


/**
 *  @brief Event attributes for the purpose of code generation.
 *
 * An event may be an input, output or internal event,
 * - input events are generated by edges on variable values, 
 * - timer events are generated by the elapse of timers,
 * - output events introduce edges on variables, and 
 * - internal events are for synchronisation only. 
 *
 * Thus, semantics are meant to match the simulator plug-in with a signal based
 * device. However, the current implementation of the code generator does
 * not support stochastic properties and the timer construct is only a subset of
 * Alur's semantics of timed automata.
 *
 * Note: in contrast to simfaudes, all priorities are non-negative from the range
 * [0,10000]. CompileDES internally re-maps priorities to ensure that input-events
 * and timer events are preferred over other events.
 *
 * File i/o by example. Typically, each attribute resides within the definition of the respective event;
 * see also CodeGenerator.
 *
 @verbatim
 % Output-event configuration with one set-action and one clear-action
 % Note: PC1 and PC2 is an abstract address to be interpreted in the context of the target platform
 <Output>
 <Priority val="20"/>
 <Actions>
 PC1 +Set+
 PC2 +Clr+
 </Actions>
 </Output>
 @endverbatim

 @verbatim
 % Output-event configuration with one execute action
 % Note: "beep(); is an abstract expression  to be interpreted in the context of the target platform
 <Output>
 <Priority val="21"/>
 <Actions>
 "beep();" +Execute+
 </Actions>
 </Output>
 @endverbatim

 @verbatim
 % Input-event configuration with two trigger conditions
 % Note: PB4 and PB5 are again abstract addresses; the static-flag triggers the event on program
 % start-up provided that the line-level PB4 evaluates high
 <Input>
 <Priority val="10"/>
 <Triggers>
 PB4 +PosEdge+ +Static+
 PB5 +NegEdge+
 </Triggers>
 </Input>
 </Event>
 @endverbatim

 @verbatim
 % Timer-event configuration configuration
 % Note: the timer starts from the top value TIME#15s when the event alpha occurs and stops when beta
 % occurs; when it reaches 0, the timer-event is triggered; the top value is interpreted in the
 % context of the target platform
 <Internal>
 <Priority val="0"/>
 <Timer val="TIME#15s">
 <ResetEvents> alpha </ResetEvents>
 <StartEvents> alpha </StartEvents>
 <StopEvents> beta   </StopEvents>
 </Internal>
 @endverbatim

 @verbatim
 % Plain event configuration
 <Internal>
 <Priority val="50"/>
 </Internal>
 @endverbatim
 *
 */

class AttributeCodeGeneratorEvent : public AttributeVoid {

FAUDES_TYPE_DECLARATION(AttributeCodeGeneratorEvent,AttributeCodeGeneratorEvent,AttributeVoid)

public:

  /*! Default constructor (internal event) */
  AttributeCodeGeneratorEvent(void) : AttributeVoid() { mType=ETInternal; mPriority=0;};

  /*! Copy constructor */
  AttributeCodeGeneratorEvent (const AttributeCodeGeneratorEvent& rOtherAttr) : AttributeVoid() 
      { DoAssign(rOtherAttr); };

  /*! Test for default value (never) */
  virtual bool IsDefault(void) const { return false;};

  /*! Clear to default */
  virtual void Clear(void);

  /*! Event types */
  typedef enum { ETInput, ETOutput, ETInternal } EventType;

  /** Event type */
  EventType mType; 

  /** Query type */
  bool Input(void) const { return mType == ETInput;};

  /** Query type */
  bool Output(void) const { return mType == ETOutput;};

  /** Query type */
  bool Internal(void) const { return mType == ETInternal;};

  /** Query type */
  bool Timer(void) const { return (mType == ETInternal) && (mTimeConstraint.mInitialValue != "");};

  /** Priority */
  Int mPriority;

  /** @brief Typedef for an individual trigger condition */
  typedef struct {
    /*! Abstract address */
    std::string mAddress;
    /*! Positive edge triggers event */
    bool  mPos;
    /*! Negative edge triggers event */
    bool  mNeg;
    /*! Fake an initial edge on initialisation to sense static levels */
    bool  mStatic;
    /*! Evaluate literal expression to trigger event */
    bool  mExe;
  } InputTrigger;

  /*! List of triggers (input events only) */
  std::vector<InputTrigger> mTriggers;

  /** @brief Typedef for an individual output action */
  typedef struct {
    /*! Abstract address */
    std::string mAddress;
    /*! Set bit */
    bool  mSet;
    /*! Clear bit */
    bool  mClr;
    /*! Literal expression i.e. function call */
    bool  mExe;
  } OutputAction;

  /*! List of actions to perform (output events only) */
  std::vector<OutputAction> mActions;

  /*! @brief Typedef for timer specification (internal events only) */
  typedef struct {
    /*! Initial value (literal to allow for advanced units, empty string for "not a timer") */
    std::string mInitialValue;
    /*! Events that start this timer */
    EventSet mStartEvents;
    /*! Events that stop this timer */
    EventSet mStopEvents;
    /*! Events that reset this timer */
    EventSet mResetEvents;
  } TimeConstraint;

  /*! Timer definition (indicate timer event iff mInitialValue non-empty) */
  TimeConstraint mTimeConstraint;

 protected:

  /**
   * Copy method
   *
   * @param rSrcAttr
   *   Source to copy from
   * @return
   *   Ref to this attribute
   */
  virtual AttributeCodeGeneratorEvent& DoAssign(const AttributeCodeGeneratorEvent& rSrcAttr);

  /**
   * Reads the attribute from TokenReader, see faudes::AttributeVoid for public wrappers.
   *
   * If the current token indicates an event configuration, the method reads that
   * section. Else it does nothing. Exceptions may only be thrown
   * on invalid data within the section. The label argument is ignored, we use the
   * hardcoded section "Input", "Output" and "Internal". The context argument is ignored.
   *
   * @param rTr
   *   TokenReader to read from
   * @param rLabel
   *   Section to read
   * @param pContext
   *   Read context to provide contextual information
   *
   * @exception Exception
   *   - IO error (id 1)
   */
  virtual void DoRead(TokenReader& rTr,const std::string& rLabel="", const Type* pContext=0);


  /**
   * Writes the attribute to TokenWriter, see AttributeVoid for public wrappers.
   *
   * Writes the event configuration data. The label argument is ignored, we use the
   * hardcoded sections "Input", "Output" and "Internal". The context argument is ignored.
   *
   * @param rTw
   *   TokenWriter to write to
   * @param rLabel
   *   Section to write
   * @param pContext
   *   Read context to provide contextual information
   *
   * @exception Exception
   *   - IO error (id 2)
   */

  virtual void DoWrite(TokenWriter& rTw,const std::string& rLabel="", const Type* pContext=0) const;

}; 

/**  @brief Convenience typedef: eventset with code-generator config attributes */
typedef TaNameSet<AttributeCodeGeneratorEvent> cgEventSet;



#endif
